import os
import time
from datetime import datetime
from log_manager import check_and_rotate_log

# --- Configuration Section ---
# Define folder paths for monitoring and logging
INBOX_FOLDER = "Inbox"
NEEDS_ACTION_FOLDER = "Needs Action"
LOGS_FOLDER = "Logs"

# Define specific log file paths
SYSTEM_LOG_FILE = os.path.join(LOGS_FOLDER, "System_Log.md") # For general activity logs
WATCHER_ERROR_LOG = os.path.join(LOGS_FOLDER, "watcher_errors.log") # For unexpected errors in the watcher script

# Set to keep track of files already processed to avoid duplicates
# This set stores filenames that have already triggered a task creation.
processed_inbox_files = set()

# --- Logging Functions ---

def _ensure_log_directory_exists():
    """Ensures the LOGS_FOLDER exists before any logging operations."""
    if not os.path.exists(LOGS_FOLDER):
        os.makedirs(LOGS_FOLDER, exist_ok=True) # exist_ok=True prevents an error if dir already exists

def log_activity(message):
    """
    Logs general activity messages to the System_Log.md file.
    Includes a timestamp for each entry.
    """
    _ensure_log_directory_exists()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_entry = f"- [{timestamp}] {message}\n"
    try:
        with open(SYSTEM_LOG_FILE, "a", encoding="utf-8") as f:
            f.write(log_entry)
        print(f"Logged activity: {message}")
    except IOError as e:
        print(f"ERROR: Could not write to System_Log.md: {e}")
        # Fallback to console if log file can't be written

def log_error(message):
    """
    Logs error messages specifically to the watcher_errors.log file.
    Includes a timestamp for each error.
    """
    _ensure_log_directory_exists()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    error_entry = f"!!! ERROR !!! [{timestamp}] {message}\n"
    try:
        with open(WATCHER_ERROR_LOG, "a", encoding="utf-8") as f:
            f.write(error_entry)
        print(f"Logged error: {message}")
    except IOError as e:
        print(f"CRITICAL ERROR: Could not write to watcher_errors.log: {e}")
        print(error_entry) # Print to console if error log itself can't be written

def initialize_logging_files():
    """
    Ensures that the System_Log.md and watcher_errors.log files (and their directory) exist.
    If they don't, it creates them with initial headers.
    """
    _ensure_log_directory_exists() # Ensure the Logs folder is there first

    # Initialize System_Log.md
    if not os.path.exists(SYSTEM_LOG_FILE):
        with open(SYSTEM_LOG_FILE, "w", encoding="utf-8") as f:
            f.write("""# System Log

## Activity Log
""")
        log_activity("Initialized System Log file.")

    # Initialize watcher_errors.log
    if not os.path.exists(WATCHER_ERROR_LOG):
        with open(WATCHER_ERROR_LOG, "w", encoding="utf-8") as f:
            f.write(f"""# Watcher Error Log

!!! Errors encountered by file_watcher.py will be recorded here. !!!
""")
        log_activity("Initialized Watcher Error Log file.")

# --- Task Creation Logic ---

def create_task_file(original_filename):
    """
    Generates a new structured task Markdown file in the 'Needs Action' folder
    for a given new file in the 'Inbox'.
    """
    task_filename = f"{original_filename}.md"
    task_filepath = os.path.join(NEEDS_ACTION_FOLDER, task_filename)

    # Prevent creating duplicate task files if one already exists for this original file.
    # This check ensures idempotency if the watcher restarts or re-detects an old file.
    if os.path.exists(task_filepath):
        print(f"Task file already exists for '{original_filename}'. Skipping creation.")
        log_activity(f"Skipped creating task for '{original_filename}' as task file already exists.")
        return

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    # This is the new structured task template
    task_content = f"""type: file review
status: pending
priority: medium
created at: {timestamp}
related files: [{original_filename}]

[Review the newly found file: {original_filename}]
[ ] Review the file content
[ ] Determine the next appropriate action
[ ] Move this task to 'Done' once completed

Notes:
(This task was automatically generated by file_watcher.py for a new file detected in the Inbox.)
"""
    try:
        with open(task_filepath, "w", encoding="utf-8") as f:
            f.write(task_content)
        print(f"Created task file: {task_filepath}")
        log_activity(f"Created task file for '{original_filename}'.")
    except IOError as e:
        # If there's an error writing the task file, log it as an error
        print(f"Error creating task file {task_filepath}: {e}")
        log_error(f"Error creating task file for '{original_filename}': {e}")

# --- File System Monitoring ---

def get_inbox_files():
    """
    Returns a set of all filenames currently in the Inbox folder.
    Handles cases where the Inbox folder might not exist.
    """
    try:
        # Filter out directories, only return actual files.
        # This prevents processing subfolders as if they were files.
        return {f for f in os.listdir(INBOX_FOLDER) if os.path.isfile(os.path.join(INBOX_FOLDER, f))}
    except FileNotFoundError:
        print(f"Warning: The '{INBOX_FOLDER}' folder was not found. It will be created.")
        log_activity(f"'{INBOX_FOLDER}' folder not found during scan, will be ensured by ensure_folders_exist().")
        return set() # Return an empty set if folder doesn't exist yet
    except Exception as e:
        # Catch any other unexpected errors during folder listing
        print(f"An unexpected error occurred while listing Inbox files: {e}")
        log_error(f"Error listing Inbox files: {e}")
        return set() # Return empty set to avoid crashing the main loop

def ensure_required_folders_exist():
    """
    Ensures that the required operational folders ('Inbox', 'Needs Action', 'Logs') exist.
    If a folder is missing, it creates it.
    """
    for folder in [INBOX_FOLDER, NEEDS_ACTION_FOLDER, LOGS_FOLDER]:
        if not os.path.exists(folder):
            os.makedirs(folder, exist_ok=True) # Create folder if it doesn't exist
            print(f"Created missing folder: {folder}")
            log_activity(f"Created missing folder: {folder}")

# --- Main Watcher Loop ---

def main():
    """
    Main function to continuously monitor the Inbox folder for new files.
    Includes robust error handling to prevent crashes.
    """
    ensure_required_folders_exist() # Ensure all necessary folders are in place
    initialize_logging_files() # Ensure all log files are ready

    print(f"Monitoring '{INBOX_FOLDER}' for new files... Press Ctrl+C to stop.")
    log_activity(f"Started monitoring '{INBOX_FOLDER}'.")

    # Populate processed_inbox_files with existing files on startup.
    # This prevents creating tasks for files that were already present
    # before the watcher started or in a previous run.
    # We check if a corresponding task file already exists in 'Needs Action'.
    initial_inbox_files = get_inbox_files()
    for filename in initial_inbox_files:
        task_filepath = os.path.join(NEEDS_ACTION_FOLDER, f"{filename}.md")
        if os.path.exists(task_filepath):
            processed_inbox_files.add(filename)
            # print(f"Found existing task for '{filename}', marking as processed to avoid re-creation.")

    while True: # Infinite loop for continuous monitoring
        try:
            # Periodically check and rotate log files to prevent them from growing indefinitely
            check_and_rotate_log(SYSTEM_LOG_FILE)
            check_and_rotate_log(WATCHER_ERROR_LOG)
            current_inbox_files = get_inbox_files()
            # Identify files that are in the inbox now but haven't been processed before
            new_files = current_inbox_files - processed_inbox_files

            for filename in new_files:
                print(f"New file detected in Inbox: {filename}")
                create_task_file(filename) # Attempt to create a task file
                processed_inbox_files.add(filename) # Mark as processed after attempt

        except KeyboardInterrupt:
            # Allow graceful exit on Ctrl+C
            print("\nWatcher stopped by user (Ctrl+C).")
            log_activity("Watcher script stopped by user.")
            break
        except Exception as e:
            # Catch any unexpected errors in the main loop iteration
            error_message = f"An unexpected error occurred in the main monitoring loop: {e}"
            print(f"ERROR: {error_message}. Resuming monitoring after a short pause.")
            log_error(error_message)
            # Sleep to prevent rapid error looping in case of persistent issues
            time.sleep(5)

        time.sleep(5) # Wait for 5 seconds before checking the inbox again

if __name__ == "__main__":
    main()