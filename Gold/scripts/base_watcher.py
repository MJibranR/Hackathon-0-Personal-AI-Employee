# scripts/base_watcher.py
import logging
import os
import time
from abc import ABC, abstractmethod
from datetime import datetime
from pathlib import Path

# Assuming all these are located relative to the script execution or absolute
VAULT_PATH = Path("AI_Employee_Vault")
NEEDS_ACTION_PATH = VAULT_PATH / "Needs_Action"
LOGS_PATH = VAULT_PATH / "Logs"

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

class BaseWatcher(ABC):
    def __init__(self, check_interval: int = 60, dry_run: bool = False):
        self.check_interval = check_interval
        self.dry_run = dry_run
        self.logger = logging.getLogger(self.__class__.__name__)
        
        # Ensure directories exist
        NEEDS_ACTION_PATH.mkdir(parents=True, exist_ok=True)
        LOGS_PATH.mkdir(parents=True, exist_ok=True)

    @abstractmethod
    def check_for_updates(self) -> list:
        """Returns a list of updates (e.g., messages, tasks)."""
        pass

    @abstractmethod
    def process_update(self, update) -> Path:
        """Processes a single update and creates a task file in Needs_Action. Returns the file path."""
        pass

    def run(self):
        self.logger.info(f"Starting {self.__class__.__name__} (Interval: {self.check_interval}s, Dry Run: {self.dry_run})")
        while True:
            try:
                updates = self.check_for_updates()
                if updates:
                    self.logger.info(f"Found {len(updates)} updates.")
                    for update in updates:
                        try:
                            file_path = self.process_update(update)
                            if file_path:
                                self.logger.info(f"Created task file: {file_path}")
                        except Exception as e:
                            self.logger.error(f"Error processing update: {e}", exc_info=True)
                else:
                    self.logger.debug("No updates found.")
            except Exception as e:
                self.logger.error(f"Watcher loop error: {e}", exc_info=True)
            
            time.sleep(self.check_interval)

    def create_task_file(self, title: str, content: str, priority: str = "Medium", tags: list = None) -> Path:
        """Helper to create a standardized markdown task file."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_title = "".join(c for c in title if c.isalnum() or c in (' ', '_', '-')).strip().replace(' ', '_')
        filename = f"{priority.upper()}_{timestamp}_{safe_title}.md"
        file_path = NEEDS_ACTION_PATH / filename

        tag_str = " ".join([f"#{t}" for t in (tags or [])])
        
        file_content = f"""---
title: {title}
created: {datetime.now().isoformat()}
priority: {priority}
status: To Do
tags: {tag_str}
source: {self.__class__.__name__}
---

# {title}

{content}

---
Generated by {self.__class__.__name__}
"""
        if self.dry_run:
            self.logger.info(f"[DRY RUN] Would create file: {file_path}")
            return None
        
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(file_content)
        
        return file_path
